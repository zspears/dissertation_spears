#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section*
Introduction
\end_layout

\begin_layout Subsection*
Motivation
\end_layout

\begin_layout Standard
Optimization has been the one of the main goals of computational since the
 beginning of computing.
 Designing something to perform optimally in all conditions is the end goal,
 but for the most part we simply focus on local optimization for a single
 application at a time.
 Optimization takes time, however.
 The optimization process can be a very long and arduous task of changing
 the value of a single variable each time and running a new simulation to
 determine what should be done with the new variable value.
 This leads to many simulations for a small benefit.
 This type of optimization tends to be so costly that it prohibits very
 large scale optimizations simply because of run time.
\end_layout

\begin_layout Standard
With this problem in mind, adjoint based optimization was implemented.
 Adjoint based optimization allows for optimization of a multitude of control
 variables in a single simulation.
 The process simply runs the simulation forward to the end of the interaction
 and then maps back the simulation values for each step with a reverse solver
 to determine the direction and magnitude that the control variables should
 be moved.
 Adjoint based optimization is not without flaws itself.
 To run an iteration of adjoint based optimization, the code must run the
 entire forward simulation, while storing every step for use in the reverse
 solver.
 This proves to be very costly for simulations of large size in either the
 time or space components.
 For real world problems, we often need at least one of those components
 to be very large, usually both.
 To get valid results for use with actual problems, we need high fidelity
 in the results, which means we need at least fairly fine meshes in the
 simulation region leading to even larger amounts of data to be stored for
 the reverse solver.
 
\end_layout

\begin_layout Standard
The adjoint problem becomes intractible for the naive approach of just simply
 writing out every step and then reading it back in when necessary.
 For this reason, the concept of checkpointing was originally applied.
 Checkpointing allows for the execution of adjoint-based optimization with
 a greatly reduced need for storage space.
 With checkpoionting, one runs a forward simulation and instead of storing
 every step, only stores a few checkpoints from which to restart the forward
 solver when the reverse solver gets to the point where it needs the steps
 between them.
 This greatly reduces the need for storage space to run a simulation.
 With improvements in how the checkpointing is done, the possible simulations
 are becoming larger and longer.
 Thanks to these advances, adjont based optimization has now become applicable
 to very large problems.
 We introduce a new implementation of checkpointing that allows for adjoint-base
d optiomization of fully 3D jet flows and noise caused by them.
\end_layout

\begin_layout Standard
Jet engine noise is a problem as old as jet fighters themselves.
 As the engines got and continue to get more powerful, the problem of engine
 noise gets continually worse.
 When looking at aircraft carriers, the problem is even larger.
 Not only are there many jets on the carrier and taking off nearly constantly,
 but the workers on the deck of the carrier are exposed to the jet noise
 from a distance much less than anywhere else.
 This creates a situation that can be extremely dangerous for the hearing
 of the aircraft carrier deck workers.
 Under OSHA regulations, a person working on the deck of a modern aircraft
 carrier could work less than eight minutes before needing to take a full
 day off.
 The noise is even more pervasive, given that when the workers retire from
 the deck for the day, they sleep only a few floors below the source of
 the noise, thus getting exposed to a portion of the noise even in down
 time.
\end_layout

\begin_layout Standard
For the simulation of the real noise generated by the jets, one also has
 to take into account the material properties of the jet engine as well
 as the cowlings and exhaust materials.
 If the materials are too flexible, the jet exhaust tip may deform and lose
 thrust or possibly cause the flow to be even more over or underexpanded,
 leading to even more noise.
 This need leads to the need of a Fluid-Structure interaction feature in
 the code.
 
\end_layout

\begin_layout Standard
Fluid Structure interaction is also important for the other main motivation
 for this research.
 That motivation is protection from blast waves created by explosions, namely
 improvised explosive devices.
 Improvised explosive devices are a plague on the military in the current
 conflicts in the middle east.
 With the improvements in body armor and military intelligence along with
 drone warfare and bombing capabilities, more of the members of the military
 are surviving the actual conflicts.
 This has pushed the insurgent members of the enemy to resort to methods
 of sneak attack.
 The sneak attacks are accomplished by either proximity or remotely activated
 explosives.
 The blast waves from these devices are proving to move directly through
 the current body armor, thus penetrating the soldiers' bodies and creating
 internal hemoraging in any cavities with air such as the lungs.
 The blasts are also causing brain injuries at a rate previously unseen.
 This is probably due again to the advances in military technology and the
 advances in medical technology that is keeping these miliotary members
 who would have died in previous conflicts.
 Since these soldiers are now going to be surviving the blasts, it is the
 duty of science to undertake the job of trying to prevent the blast induced
 brain injuries that are now becoming a major problem for the returning
 soldiers.
\end_layout

\begin_layout Subsection*
Background
\end_layout

\begin_layout Subsubsection*
CFD
\end_layout

\begin_layout Standard
Computational Fluid Dynamics is a field of computational physics that models
 the flows of fluids.
 This uses boundary conditions and definitions of the gas or fluid constitution
 in order to simulate the interaction of the fluids in the flow and the
 surrounding fluid.
\end_layout

\begin_layout Subsubsection*
LES
\end_layout

\begin_layout Standard
Large Eddy Simulations are simulations of fluid dynamics that include near
 field and far field flows of trubulent flows.
 They allow for better resolution than RANS models and better computational
 efficiency than DNS models.
 
\end_layout

\begin_layout Subsubsection*
Unsteady Simulations
\end_layout

\begin_layout Standard
The simulations used in the studies are unsteady in nature, meaning that
 the flow does not ever reach a steady state and is in constant flux.
 
\end_layout

\begin_layout Subsubsection*
Unstructured Grids
\end_layout

\begin_layout Standard
The code is built on unstructured grids, allowing for much more intricate
 geometries than are possible for the same number of elements in a structured
 code.
 It also allows for easier refinement in some regions without need for global
 refinement.
 
\end_layout

\begin_layout Subsubsection*
CSD
\end_layout

\begin_layout Standard
Computational Structural Dynamics models the motion and reaction of solids
 during collisions and in response to stresses from inside and outside forces.
 
\end_layout

\begin_layout Subsubsection*
FSI
\end_layout

\begin_layout Standard
Fluid-Structure Interaction is a coupling of a fluid solver with a structural
 sover in order to model the reaction of a solid to changes in a fluid flow
 and in return the reactions of the fluid flow to the solid and the chasnges
 in the solid.
 
\end_layout

\begin_layout Subsubsection*
Adjoint-Based Optimization
\end_layout

\begin_layout Standard
Optimization of a flow with respect to a certain trait that one would like
 to minimize or maximize.
 Given a control surface with n points, adjoint-based optimization can give
 a large step toward the optimal solution for roughly the cost of 2-3 forward
 simulation compared to n forward simulations with standard optimization
 techniques.
\end_layout

\end_body
\end_document
